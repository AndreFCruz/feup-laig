\documentclass[a4paper]{article}

%use the english line for english reports
%usepackage[english]{babel}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Prolog,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
  }

\begin{document}


\setlength{\textwidth}{16cm}
\setlength{\textheight}{22cm}

\title{\Huge\textbf{FABRIK}\linebreak\linebreak\linebreak
\Large\textbf{Manual do Utilizador}\linebreak\linebreak
\linebreak\linebreak
\includegraphics[scale=0.1]{images/feup-logo.png}\linebreak\linebreak
\linebreak\linebreak
\Large{Mestrado Integrado em Engenharia Informática e Computação} \linebreak\linebreak
\Large{Laboratório de Aplicações com Interface Gráfica}\linebreak
}

\author{\textbf{Turma 1, Grupo 7}\\
\linebreak\\
André Cruz - 201503776 \\
Edgar Carneiro - 201503748 \\
\linebreak\linebreak \\
 \\ Faculdade de Engenharia da Universidade do Porto \\ Rua Roberto Frias, s\/n, 4200-465 Porto, Portugal \linebreak\linebreak\linebreak
\linebreak\linebreak\vspace{1cm}}

\maketitle
\thispagestyle{empty}

%************************************************************************************************
%************************************************************************************************

\newpage


\tableofcontents

%************************************************************************************************
%************************************************************************************************

%*************************************************************************************************
%************************************************************************************************

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Instruções de Uso}

Para correr o cliente (interface gráfica) basta correr o script ‘start\_client.sh’:
\begin{itemize}
\item \verb|sh start_client.sh|
\end{itemize}

No caso de não ser possível correr shell scripts terá de correr o comando ‘python -m http.server 8080’ manualmente.
\\
\\
Para correr o servidor de prolog terá de correr o script ‘start\_server.sh’:
\begin{itemize}
\item \verb|sh start_server.sh|
\end{itemize}

No caso de não ser possível correr shell scripts terá de abrir o Sicstus, consultar o ficheiro de Prolog server.pl - consult(‘server.pl’). - e de seguida correr o predicado server.

Após ter iniciado o servidor http e o servidor de prolog, basta navegar até à página ‘localhost:8080/client’ para correr o jogo.


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{O Jogo \textit{Fabrik}}

\subsection{História}
O jogo - \textit{Fabrik} - foi recentemente desenvolvido por Dieter Stein, em agosto de 2017, como parte de um estudo para o desenvolvimento de um novo jogo, Urbino.

\subsection{Material}
\begin{itemize}
	\item Tabuleiro quadrangular
	\item Quantidade suficiente de peças pretas e brancas
	\item Duas peças vermelhas chamadas trabalhadores
\end{itemize}

\begin{figure}[h!]
\begin{center}
\includegraphics[height=3cm,width=3cm]{images/fabrik_empty_board.png}
\caption{Tabuleiro vazio de 11 x 11 espaços}
\label{Figura 1}
\end{center}
\end{figure}

\subsection{Regras}
A implementação deste jogo foi baseada no manual de regras oficiais \cite{games_and_puzzles_by_dieter_stein}.

As pretas (jogador que joga com peças de cor preta) começam por colocar um dos trabalhadores num espaço à sua escolha. De seguida, as brancas (jogador que joga com peças de cor branca) colocam o outro trabalhador num espaço livre. De seguida, as pretas decidem quem começa por jogar.

O jogo procede por turnos, sendo que em cada turno um jogador pode, se assim optar, mover um dos trabalhadores para um espaço vazio. De seguida, o jogador deve jogar colocar uma das suas peças num ponto de interseção entre as “linhas de visão dos dois trabalhadores”. As linhas de visão dos trabalhadores são as linhas na diagonal, horizontal e vertical sobre as quais os trabalhadores se encontram posicionados.

\begin{figure}[h!]
\begin{center}
\includegraphics[height=3cm,width=3cm]{images/fabrik_intersection.png}
\caption{Pontos de interseção entre os dois trabalhadores}
\label{Figura 2}
\end{center}
\end{figure}

No caso especial em que os dois trabalhadores se encontram sobre uma mesma linha ortogonal ou diagonal, apenas os espaços entre eles são considerados pontos de interseção (se estiverem vazios), ao invés da totalidade dessa linha.

Ganha o jogo o jogador que consiga criar uma linha de pelo menos 5 pedras da sua cor, ortogonal ou diagonalmente. Um jogador ganha também o jogo se o seu adversário não conseguir posicionar nenhum dos trabalhadores de forma a poder colocar uma pedra sua no tabuleiro.

\begin{figure}[h!]
\begin{center}
\includegraphics[height=3cm,width=3cm]{images/fabrik_full_board.png}
\caption{Final de uma partida de Fabrik, com vitórias das pretas}
\label{Figura 3}
\end{center}
\end{figure}


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lógica do Jogo}

Descrever o projeto e implementação da lógica do jogo em Prolog, incluindo a forma de representação do estado do tabuleiro e sua visualização, execução de movimentos, verificação do cumprimento das regras do jogo, determinação do final do jogo e cálculo das jogadas a realizar pelo computador utilizando diversos níveis de jogo. Sugere-se a estruturação desta secção da seguinte forma:

\subsection{Representação do Estado do Jogo}

A representação dos estados de jogo é feita com recurso a uma lista de listas, de forma a simular o uso de uma Matriz. Seguem de seguida a representação de diferentes estados de jogo:\newline


Representação do \textbf{estado inicial}:

\begin{small}
\begin{lstlisting}
[[none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none],
 [none, none, none, none,  none, none,  none, none, none, none, none]]
\end{lstlisting}
\end{small}

\begin{figure}[h!]
\centering
\begin{minipage}{.35\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/self_empty_board.png}
	\caption{Representação do estado inicial na consola}
	\label{Figura 4}
\end{minipage}
\quad \quad
\begin{minipage}{.35\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/fabrik_empty_board.png}
	\caption{Tabuleiro original Vazio}
	\label{Figura 5}
\end{minipage}
\end{figure}

\clearpage

Representação de um possível \textbf{estado intermédio}:\newline

\begin{small}
\begin{lstlisting}
[[ none, none, none, none, none, none, none, none, none, none, none],
 [ none, none, none, none, none, white, worker, none, none, none, none],
 [ none, none, none, none, none, none, white, black, white, none, none],
 [ none, white, white, none, none, none, none, white, white, none, none],
 [white, none, none, none, black, black, none, black, none, none, none],
 [ none, none, black, white, none, none, none, none, white, none, none],
 [ none, black, none, none, none, black, black, black, none, none, none],
 [ none, none, none, none, none, none, black, none, white, none, none],
 [ none, none, none, none, none, black, none, none, none, none, none],
 [ none, none, none, none, worker, none, none, none, none, none, none],
 [ none, none, none, none, none, none, none, none, none, none, none]]
\end{lstlisting}
\end{small}

\begin{figure}[h!]
\begin{center}
	\includegraphics[height=6cm, width=6cm]{images/self_semi_board.png}
	\caption{Representação na consola, de um possível estado intermédio}
	\label{Figura 6}
\end{center}
\end{figure}

\clearpage
Representação de um possível \textbf{estado final}:\newline

\begin{small}
\begin{lstlisting}
[[ none, none, none, none, white, none, none, none, none, none, none],
 [ none, white, none, white, none, white, white, none, none,white, none],
 [ none, white, none, white, none, none,white, black, white, none, none],
 [black, white, white, none, none, none, none, white, white, none, none],
 [white, none, black, none,black, black, black, black, none, none, none],
 [none, black, black, white,white, black, none, black,white, none, none],
 [white, black, none,black, none, black, black, black, none, none, none],
 [ none, none, none, none, worker, black, black, none,white, none, none],
 [white, black, none, none,black, black, none, none, none, worker, none],
 [ none, none, none, none, none, none, none, none, none, none, none],
 [ none, none, black, none, none, none, none, white, none, none, none]]
\end{lstlisting}
\end{small}

\begin{figure}[h!]
\centering
\begin{minipage}{.35\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/self_full_board.png}
	\caption{Representação do estado final na consola}
	\label{Figura 7}
\end{minipage}
\quad \quad
\begin{minipage}{.35\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/fabrik_full_board.png}
	\caption{Representção do mesmo estado final, no tabuleiro original}
	\label{Figura 8}
\end{minipage}
\end{figure}

\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visualização do Tabuleiro}

Para a representação do tabuleiro em modo de texto, foi criado o seguinte código em prolog:
\begin{lstlisting}[language=prolog]
% Dictionary for Board Elements
translate(none, 32). %Empty Cell
translate(black, 79). %Dark Pieces
translate(white, 88). %White Pieces
translate(worker, 9608). %Red Workers

(...)

% General PrintBoard
printBoard(Board):-
        boardSize(N),
        printBoard(Board, N), !.

% Board Printing - arguments: Board and Board size
printBoard(Board, N):-
        clearConsole,
        write('  '), printHorizontalLabel(N, N),
        printBoard(Board, N, 1), !.

printBoard([], N, _):-
        printRowDivider(N), nl.

printBoard([Line | Board], N, CurrentL):-
        printRowDivider(N),
        printDesignRow(N),
        printVerticalLabel(CurrentL),
        put_code(9474),
        printLine(Line),
        printDesignRow(N),
        NewL is (CurrentL + 1),
        printBoard(Board, N, NewL).

printLine([]):- nl.
printLine([Head | Tail]) :-
        translate(Head, Code),
        write('   '),
        put_code(Code),
        write('   '), put_code(9474),
        printLine(Tail).

%  AESTHETICS

printRowDivider(N):-
        write('  '),
        put_code(9532),
        printRowDividerRec(N).

printRowDividerRec(0) :- nl.
printRowDividerRec(N) :-
        put_code(9472), put_code(9472), put_code(9472), put_code(9472),
        put_code(9472), put_code(9472), put_code(9472), put_code(9532),
        N1 is (N-1),
        printRowDividerRec(N1).

printDesignRow(N):-
        write('  '),
        put_code(9474),
        printDesignRowRec(N).

printDesignRowRec(0) :- nl.
printDesignRowRec(N) :-
        write('       '), put_code(9474),
        N1 is (N-1),
        printDesignRowRec(N1).

%Dictionary for Labels
getLabel( 0, 'A').
getLabel( 1, 'B').
getLabel( 2, 'C').
getLabel( 3, 'D').
getLabel( 4, 'E').
getLabel( 5, 'F').
getLabel( 6, 'G').
getLabel( 7, 'H').
getLabel( 8, 'I').
getLabel( 9, 'J').
getLabel(10, 'K').
getLabel(11, 'L').
getLabel(_,_):-
        write('Error: Unrecognized Label.'), nl,
        fail.

printHorizontalLabel(0, _):- nl.
printHorizontalLabel(N, Total):-
        Pos is (Total-N),
        getLabel(Pos, L),
        write('    '), write(L), write('   '),
        N1 is (N-1),
        printHorizontalLabel(N1, Total).        

printVerticalLabel(CurrentL):-
        CurrentL < 10,
        write(CurrentL),
        write(' ').

printVerticalLabel(CurrentL):-
        write(CurrentL).

\end{lstlisting}

\newpage

Representação de um tabuleiro, usando o código mencionado:\newline

\begin{figure}[h!]
\begin{center}
	\includegraphics[height=4cm, width=4cm]{images/self_semi_board.png}
	\caption{Representação de um tabuleiro na consola}
	\label{Figura 9}
\end{center}
\end{figure}

\newpage

\subsection{Lista de Jogadas Válidas}

A obtenção da lista de jogadas é feita através do predicado \textbf{getIntersections (Board, Row1, Col1, Row2, Col2, Positions)}, que dadas as posições dos dois Trabalhadores calcula as interseções das suas linhas de visão. O cálculo das linhas de visão de um trabalhador é feito através do predicado \textbf{positionsInSight (Board, Row1, Col1, Pos1)}. Este predicado, calcula o campo de visão de um Trabalhador analisando todas as direções desda posição do Trabalhador até encontrar uma posição que não se encontra vazia.

\newpage

\subsection{Execução de Jogadas}

No início do jogo, são colocados os dois Trabalhadores nas posições iniciais, usando o predicado \textbf{setPiece(+Piece, +Row, +Col, +Board, -NewBoard)}. Este predicado coloca os Trabalhadores na posição dada desde que esta posição esteja vazia. A validade de uma jogada é sempre avaliada usando o predicado \textbf{isValidPlay (+PieceType, +Row, +Col, +Board)}.

No decorrer do jogo, cada jogada pode ser divida em duas partes distintas:  a movimentação, se o jogador assim o desejar, de um dos Trabalhadores e a colocação de uma peça no tabuleiro. Analizemos cada um destes processos em distinto:
\begin{itemize}
	\item A movimentação de um Trabalhador é feita através do predicado \textbf{moveWorker/6} que recebendo a posição tual do Trabalhador, a nova posição do Trabalhador e o tabuleiro, verifica que a nova posição se encontra vazia e move o Trabalhador para essa posição, devolvendo o tabuleiro atualizado. A movimentação da peça é feita através da colocação de uma célula vazia na posição anterior e a colocação do Trabalhador na nova posição, usando para ambas as ações o predicado \textbf {setPiece(+Piece, +Row, +Col, +Board, -NewBoard)}.
	\item A colocação de uma nova peça no tabuleiro é feita através do predicado \textbf{pieceInput/4}, que por sua vez faz uso do predicado \textbf{setPiece(+Piece, +Row, +Col, +Board, -NewBoard)}. Este predicado recebe um tipo de peça e coloca-a no tabuleiro, após verificar que a jogada é válida. No caso das peças serem pretas ou brancas, a validade da jogada passa pela posição indicada estar vazia e pela posição ser uma interseção das linhas de visão dos Trabalhadores.
\end {itemize}

\newpage

\subsection{Avaliação do Tabuleiro}

A avaliação do jogo pode ser conceptualmente divida em duas partes: a análise de sequências de peças, quer da própria cor, quer de peças adversárias; e o bloqueio de sequências de peças adversárias. As peças adversárias têm cotação negativa, enquanto as peças da mesma cor tem cotação positiva.

Na primeira fase, de forma a valorizar a realização de sequências, cada peça terá valor associado igual ao cubo da posição na sequência que ocupa. Exemplificando, uma sequência de três peças na horizontal tira respetiva valorização de: (1\textasciicircum3) + (2\textasciicircum3) + (3\textasciicircum3), ou seja, 1 + 8 + 27; enquanto uma sequência de três peças opostas teria o valor de (-1) + (-8) + (-27). Resumindo, a análise de cada peça é feita através da formula:
\begin{itemize}
	\item \textbf{ NumSequência\textasciicircum3} - para peças da mesma cor;
	\item \textbf{- (NumSequência\textasciicircum3)} - para peças adversárias;
\end{itemize}
Esta análise é feita nos quatro sentidos possíveis: horizontalmente, da esquerda para a direita; verticalmente, de cima para baixo; diagonalmente, com orientação ascendente; diagonalmente, com orientação descente.

A segunda fase, surgiu como necessidade de a peça não permitir a realização de sequências por parte do adversário. Se apenas se usasse a primeira fase de avaliação as peças nunca tentariam quebrar sequências inimigas, mas sim realizar as suas sequências. Assim, para evitar que isso aconteça, uma peça que quebre uma sequência inimiga, vale tanto como a sequência que quebra. Esta avaliação é feita analisando as peças adjacentes a cada peça da mesma cor, e, se a peça adjacente for inimiga, analisa-se a peça seguinte nessa linha, sendo que no final é adicionado o valor da sequência adversária. Exemplificando, uma sequência de três peças inimigas , a adição de uma peça que quebra esse sequência teria o valor de 1 + 4 + 27. Resumindo, a análise do bloqueio de sequências adversárias é feita através da fórmula (para cada sequência quebrada):
\begin{itemize}
	\item \textbf{(NumSequênciaAdversária\textasciicircum3) * factorDefesa}
\end{itemize}
De destacar, que após vários testes o factor de Defesa foi definido para 1 sendo este o valor que maior equilíbrio dá entre `ataque' e `defesa'.

A avaliação do tabuleiro é feita através da chamada do predicado:
\begin{itemize}
	\item \textbf{evaluateBoard(+Side, +Board, +BoardValue)}
\end{itemize}

Que por sua vez usa os predicados:
\begin{itemize}
	\item \textbf{horizontalEvaluation(+Side, +Board, -HorizontalValue)}
	\item \textbf{verticalEvaluation(+Side, +Board, -VerticalValue)}
	\item \textbf{diagonalEvaluation(+Side, +Board, -DiagonalValue)}
	\item \textbf{defensiveEvaluation(+Side, +Board, -DefensiveValue)}
\end{itemize}

\newpage

\subsection{Final do Jogo}

Existem três maneiras possíveis de terminação do jogo: a inexistência  de posições que sejam a interseção da linha de visão dos Trabalhadores; o tabuleiro estar cheio e não ser possível mover um Trabalhador; a existência de cinco em linha de um tipos de peças.
Assim, internamente, a verificação destas condições é feita de três formas distintas:
\begin{itemize}
	\item No caso de uma jogada feita pelo utilizador, após a colocação dos Trabalhadores no tabuleiro é verificado se é possível a execução de uma jogada, recorrendo ao predicado \textbf{isPiecePlayPossible(+Board)}, que verifica se a interseção das linhas de visão dos dois trabalhadores não é uma lista vazia. Caso a lista seja vazia, a primeira declaração do predicado \textbf{gameLoop/4}, que controla o ciclo de jogo, falhará, realizando assim a segunda declaração, que declara vitorioso o adversário e termina o ciclo de jogo. No caso de uma jogada controlada automaticamente, caso a lista dos tabuleiros possíveis, correspondentes a uma jogada, seja vazia, é declarada a vitória do adversária, num processo semelhante ao executado para o jogador.
	\item No início de cada jogada é verificado a se o tabuleiro se encontra totalmente preenchido, não sendo assim possível mexer \textit{workers} ou posicionar peças. Esta verificação é realizada através do predicado \textbf{boardIsNotFull(+Board)}, que itera pelo tabuleiro até encontrar uma posição vazia. Caso não seja possível, a primeira declaração do ciclo de jogo falha e, à semelhança do ponto anterior, o jogador adversário é declarado vitorioso.
	\item No final de cada jogada, é verificada a vitória desse jogador. Para tal, o predicado \textbf{decideNextStep/4} chama o predicado \textbf{gameIsWon(+Side, +Board)}, que, fazendo uso dos predicados \textbf{checkHorizontalWin(+PieceSide, +Board)}, \textbf{checkVerticalWin(+PieceSide, +Board)} e \textbf{checkDiagonalWin (+PieceSide, +Board)}, verifica se existem 5 peças em linha, significando assim a vitória do jogador atual. Caso nenhum destes predicados se verifique, o predicado \textbf{decideNextStep/4} volta a chamar o ciclo do jogo, par ao próximo jogador.
\end{itemize}

\newpage

\subsection{Jogada do Computador}
Para este projeto desenvolvemos dois bots:  um \textbf {Random bot}, que realiza uma jogada aleatória e uma \textbf{Greedy Bot} que realiza uma jogada de forma a obter o tabuleiro que ele considera ser o mais vantajoso. Explicando melhor como cada um dos bots funcionam temos:
\begin{itemize}
 	\item \textbf{\textit{Random Bot}}: Este bot obtém a jogada que deve escolher através do predicado \textbf{getRandomPlay (+Side, +CurrentBoard, -Play)}. Este predicado, escolhe aleatoriamente um dos tabuleiros de entre todos os tabuleiros que é possível obter através do movimento de Trabalhor seguido da colocação de uma peça. Todos os tabuleiros possíveis gerar encontrm-se guardados numa lista, que é computada no predicado \textbf{getPossibleBoards(+Side, +CurrentBoard, -PossibleBoards)}.
	\item\textbf{\textit{Greedy Bot}}: Tal como o bot aleatório este bot obtem a lista de todos os tabuleiros mas apenas escolhe aquele que considera ser mais vantajoso, através do predicado \textbf{evaluateAllBoards(+Side, +PossibleBoards, -GradedBoards)} que aplicação a função de avaliação já descrita a todos os tabuleiros, sendo que depois escolhe aquele que tem maior valor, através de um \textbf{keysort}.
\end{itemize}

\newpage

\end{document}
